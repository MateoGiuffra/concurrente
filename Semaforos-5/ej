/*Ejercicio 1. Se busca computar la suma de los primeros N n ́umeros impares utilizando dos
threads llamados generador y acumulador, que deben cooperar entre s ́ı para resolver esta tarea.
Contamos con dos variables globales impar, que comienza inicializada en N, y suma, que comienza
inicializada en 0. Buscamos que generador se encargue de que impar contenga el valor i cuando
se deba sumar el i- ́esimo n ́umero impar, y que acumulador compute cu ́al es el i- ́esimo impar y lo
sume a suma. Al finalizar el c ́omputo, el thread generador debe imprimir el valor correcto de la
sumatoria.
a) Escriba un programa concurrente que funcione seg ́un esta din ́amica.
b) ¿Qu ́e modificaci ́on deber ́ıa hacerse si existieran m ́ultiples threads generador? ¿Y si hubieran
m ́ultiples threads acumulador? ¿Existe posibilidad de starvation?
*/

// a
impar = N 
suma = 0
Semaphore permisoAcumulador = new Semaphore(1)
Semaphore permisoGeneral = new Semaphore(1)

thread generador{
    while (impar > 1)
    {
        permisoGeneral.acquiere()
        impar --; 
        permisoAcumulador.release()
    }
    permisoGenerar.acquire()
    print(suma)
}

thread acumulador{
    while (impar != 1)
    {
        permisoAcumulador.acquire()
        suma += 2 * impar - 1
        permisoGenerador.release()
    }
    suma += 1 
    permisoGeneral.release()    
}

/*
Ejercicio 3. En un gimnasio hay cuatro aparatos, cada uno para trabajar un grupo muscular
distinto. Los aparatos son cargados con discos (el gimnasio cuenta con 20 discos, todos del mismo
peso). Cada cliente del gimnasio posee una rutina que le indica qu ́e aparatos usar, en qu ́e orden
y cuanto peso utilizar en cada caso (asuma que la rutina es una lista de tuplas con el n ́umero de
aparato a usar y la cantidad de discos cargar, la rutina podr ́ıa incluir repeticiones de un mismo
aparato). Como norma el gimnasio exige que cada vez que un cliente termina de utilizar un
aparato descargue todos los discos y los coloque en el lugar destinado a su almacenamiento (lo
que incluye usos consecutivos del mismo aparato).
a) Indique cuales son los recursos compartidos y roles activos.
b) Escriba un codigo que simule el funcionamiento del gimnasio, garantizando exclusi ́on mutua
en el acceso a los recursos compartidos y que est ́e libre de deadlock y livelock.
Ayuda: Considere modelar a los clientes como threads (cada uno con su propia rutina) y a
los aparatos como un arreglo de sem ́aforos.

[(numAparato, cantDiscos),(numAparato, cantDiscos)]

4 aparatos
20 discos
cliente -> rutina:
                - aparatos a usar
                - orden 
                - peso en cada aparto 
                - repeticiones por aparato

roles:
- cliente 

*/
p1 = [(1, 20),(1, 20)]
// []
p2 = [(1, 20),(1, 20)]

// 4 => 0 
// pj 5 => pj duerme 
// []

Semaphore[] aparatos = new Semaphore[4]{1,1,1,1} // FUERTE
Semaphore discos = new Semaphore(20)
Semaphore mutex = new Semaphore(1)

thread cliente(tupla){
    // a index de aparato
    // d cant de discos  
    for a, c in tuplas{
        aparatos[a].acquiere()  

        mutex.acquire()
        cantDiscos.acquire(d)
        mutex.release()
        // hacer rutina
        aparatos[a].release()  

        cantDiscos.release(d)
    }
}


/*
Ejercicio 4. 
En un famoso shopping de la ciudda se agrego un puesto de tintorerıa automatica
para que la gente pueda dejar su ropa mientras recorre los locales. Novedosamente, estas maquinas 
entregan un beeper a la gente que parpadea para indicar que la ropa ya esta lista para ser retirada. 
Hay K maquinas de lavado listas para funcionar. Cada persona que quiere utilizar el
servicio (en este ejemplo no modelaremos a quieres no lo requieran) espera que haya alguna
maquina disponible para serle asignada segun disponibilidad, carga su ropa y recibe su beeper.
Luego, se va a mirar locales, y si al terminar su beeper a ́un no parpadea, espera que lo haga
para volver al local y retirar sus prendas (Si el beeper parpadea mientras la persona a ́un esta
mirando locales, esta lo ignora hasta que est ́a por retirarse). Modele este escenario por medio de
semaforos. 
Procure que no suceda que una persona vaya a retirar su ropa cuando se termino de
procesar la de alguien mas. O sea el beeper es unico por persona. 

- K maquinas
- Persona elige una, carga sus cosas 
- Le dan beeper
- Espera a que suene el beeper
- Retira sus prendas


// */
// Semaphore[] maquinas = new Semaphore[K]{1 ... } // fuerte
// Semaphore[] beepers = new Semaphore[K]{1 ... } 
// Semaphore[] notificador = new Semaphore[K]{0 ... } 

// thread maquina{
//     // limpiando
//     while(true){
//         notificador[idMaquina].release()
//     }
// }

// thread cliente (idMaquina){
//     maquinas[idMaquina].acquiere()
//     // pone su ropa
//     beepers[idMaquina].acquiere()
//     // va a recorrer locales 
//     notificador[idMaquina].acquiere()
//     // va a retirar la ropa
//     beepers[idMaquina].release()
//     maquinas[idMaquina].release()
// }


Semaphore permisoUsar(1)
Semaphore hayMaq(0)
global proximaMaq = -1
Semaphore permisoCargarRopa[K]{0 ...}
Semaphore beepers[K]{0 ...}

thread maquina(id){
    while(true){
        permisoUsar.acquiere()
        proximaMaq = id 
        hayMaq.release()
        permisoCargar[id].acquire()
        // lavar
        beepers[miMaq].release()
        permisoDescargar[id].acquiere()
    }
}

thread persona(){
    hayMaq.acquiere()
    miMaq = proximaMaq
    permisoUsar.release()
    // cargar ropa
    permisoCargarRopa[miMaq].release()
    // recorrer 
    beepers[miMaq].acquire()
    // retirar
    permisoDescargar[miMaq].release()

}